/*
 * SetHierarchie.java
 *
 * Created on 19. Dezember 2007, 10:13
 */

package multidstrukt;


import javax.swing.tree.*;
import javax.swing.*;
import org.jdesktop.application.Action;
import structures.*;

/**
 * Dialog zur Definition von Hierarchien.
 * @author  khadikov, hagedorn
 */
public class SetHierarchie extends javax.swing.JDialog {
    
    /** Creates new form SetHierarchie */
    public SetHierarchie(java.awt.Frame parent, boolean modal,int dimNr) {
        super(parent, modal);
        // initialisiert Instanzvariablen
        this.dimNr=dimNr;
        IDC idc=MultiDstruktApp.getApplication().getIDC();
        int dim=idc.getShape().length;
        this.rootArray=new DefaultMutableTreeNode[dim];
        this.treeArray=new DefaultTreeModel[dim];
        String[] description=idc.getDescription();
        changed=new boolean[dim];
        // Erzeugt fuer jede Dimension einen Baum aus der Hierarchie
        for (int i=0;i<dim;i++){
            // Falls noch keine Hierarchie definiert ist, wird nur eine Wurzel mit Bezeichnung der Dimension erzeugt.
            if (idc.dimension[i].getHierarchie()==null){
                this.rootArray[i]=new DefaultMutableTreeNode(description[i]);
                this.treeArray[i]=new DefaultTreeModel(rootArray[i]);
            }
            else{
                createTree(idc.dimension[i].getHierarchie(),i);
            }
            changed[i]=false;
        }
        this.rootNode=this.rootArray[dimNr];
        this.treeModel=this.treeArray[dimNr];
        initComponents();        
        this.dimChange.setSelectedIndex(this.dimNr);
        
    }
    /**
     * Erzeugt aus einer Hierarchie einen Baumknoten.
     * @param hierarchie
     * @return Baumknoten, der alle noetigen Informationen der Hierarchie enthaelt.
     */
    private DefaultMutableTreeNode createNode(DimensionHierarchie hierarchie) {
        DimensionHierarchie[] children=hierarchie.getChildren();
        DefaultMutableTreeNode result;
        // Bei einem Blatt wird Name der Hierarchie und Range gespeichert, bei innerem Knoten nur der Name
        if (children==null||children.length==0){
            LoHiList hilo=hierarchie.getLoHi();
            int low=hilo.head.low;
            int high=hilo.head.high;
            HierarchieInfo hi=new HierarchieInfo(hierarchie.getName(),low,high);
            return new DefaultMutableTreeNode(hi,false);
        }
        else
            result=new DefaultMutableTreeNode(new HierarchieInfo(hierarchie.getName()));
        // Kinderknoten werden zum Baum hinzugefuegt    
        for (int j=0;j<children.length;j++){
            this.addObject(result, createNode(children[j]),false);
        }
            
        return result;
    }
    /**
     * Erzeugt den Baum zu einer Hierarchie
     * @param hierarchie
     * @param i Index der Dimension
     */
    private void createTree(DimensionHierarchie hierarchie, int i) {
        DimensionHierarchie[] children=hierarchie.getChildren();
        // Wurzel wird erzeugt
        if (children==null||children.length==0){
            this.rootArray[i]=new DefaultMutableTreeNode(new HierarchieInfo(hierarchie.getName(),hierarchie.getLoHi().head.low,hierarchie.getLoHi().head.high));
            this.treeArray[i]=new DefaultTreeModel(rootArray[i]);
            return;       
        }
        this.rootArray[i]=new DefaultMutableTreeNode(hierarchie.getName());
        this.treeArray[i]=new DefaultTreeModel(rootArray[i]);
        this.treeModel=this.treeArray[i];
        this.rootNode=this.rootArray[i];
        // Kinder werden ebenfalls hinzugefuegt.    
        for (int j=0;j<children.length;j++){
            this.addObject(rootNode, createNode(children[j]),false);            
        }          
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        mainpanel = new javax.swing.JPanel();
        ClearButton = new javax.swing.JButton();
        OKButton = new javax.swing.JButton();
        TreePane = new javax.swing.JScrollPane();
        TreePane = new javax.swing.JScrollPane();
        tree = new javax.swing.JTree(treeModel);
        nodeInfo = new javax.swing.JPanel();
        LeafBox = new javax.swing.JCheckBox();
        jLabel3 = new javax.swing.JLabel();
        NameField = new javax.swing.JTextField();
        jLabel2 = new javax.swing.JLabel();
        lowText = new javax.swing.JTextField();
        highText = new javax.swing.JTextField();
        jLabel1 = new javax.swing.JLabel();
        ConfirmButton = new javax.swing.JButton();
        CancelButton = new javax.swing.JButton();
        dimChange = new javax.swing.JComboBox();
        dimName = new javax.swing.JLabel();
        AddNode = new javax.swing.JButton();
        RemoveButton = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(multidstrukt.MultiDstruktApp.class).getContext().getResourceMap(SetHierarchie.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setLocationByPlatform(true);
        setModal(true);
        setName("Form"); // NOI18N
        setResizable(false);

        mainpanel.setMaximumSize(new java.awt.Dimension(300, 300));
        mainpanel.setName("mainpanel"); // NOI18N

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(multidstrukt.MultiDstruktApp.class).getContext().getActionMap(SetHierarchie.class, this);
        ClearButton.setAction(actionMap.get("clearButton")); // NOI18N
        ClearButton.setToolTipText(resourceMap.getString("ClearButton.toolTipText")); // NOI18N
        ClearButton.setName("ClearButton"); // NOI18N

        OKButton.setAction(actionMap.get("okButtonPressed")); // NOI18N
        OKButton.setText(resourceMap.getString("OKButton.text")); // NOI18N
        OKButton.setToolTipText(resourceMap.getString("OKButton.toolTipText")); // NOI18N
        OKButton.setName("OKButton"); // NOI18N

        TreePane.setName("TreePane"); // NOI18N

        setName("Form"); // NOI18N

        TreePane.setName("TreePane"); // NOI18N
        tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
        tree.setEditable(true);
        tree.setName("tree"); // NOI18N
        TreePane.setViewportView(tree);

        nodeInfo.setBorder(javax.swing.BorderFactory.createTitledBorder(resourceMap.getString("nodeInfo.border.title"))); // NOI18N
        nodeInfo.setName("nodeInfo"); // NOI18N

        LeafBox.setAction(actionMap.get("enableDisableButtons")); // NOI18N
        LeafBox.setText(resourceMap.getString("LeafBox.text")); // NOI18N
        LeafBox.setToolTipText(resourceMap.getString("LeafBox.toolTipText")); // NOI18N
        LeafBox.setEnabled(false);
        LeafBox.setName("LeafBox"); // NOI18N

        jLabel3.setText(resourceMap.getString("jLabel3.text")); // NOI18N
        jLabel3.setEnabled(false);
        jLabel3.setName("jLabel3"); // NOI18N

        NameField.setText(resourceMap.getString("NameField.text")); // NOI18N
        NameField.setEnabled(false);
        NameField.setName("NameField"); // NOI18N

        jLabel2.setText(resourceMap.getString("jLabel2.text")); // NOI18N
        jLabel2.setEnabled(false);
        jLabel2.setName("jLabel2"); // NOI18N

        lowText.setText(resourceMap.getString("lowText.text")); // NOI18N
        lowText.setEnabled(false);
        lowText.setName("lowText"); // NOI18N

        highText.setText(resourceMap.getString("highText.text")); // NOI18N
        highText.setEnabled(false);
        highText.setName("highText"); // NOI18N

        jLabel1.setText(resourceMap.getString("jLabel1.text")); // NOI18N
        jLabel1.setEnabled(false);
        jLabel1.setName("jLabel1"); // NOI18N

        ConfirmButton.setAction(actionMap.get("confirmed")); // NOI18N
        ConfirmButton.setToolTipText(resourceMap.getString("ConfirmButton.toolTipText")); // NOI18N
        ConfirmButton.setEnabled(false);
        ConfirmButton.setName("ConfirmButton"); // NOI18N

        javax.swing.GroupLayout nodeInfoLayout = new javax.swing.GroupLayout(nodeInfo);
        nodeInfo.setLayout(nodeInfoLayout);
        nodeInfoLayout.setHorizontalGroup(
            nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(nodeInfoLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(LeafBox)
                    .addComponent(ConfirmButton, javax.swing.GroupLayout.PREFERRED_SIZE, 87, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(52, 52, 52)
                .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jLabel3)
                    .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 41, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addGap(33, 33, 33)
                .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(highText, javax.swing.GroupLayout.PREFERRED_SIZE, 83, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(lowText, javax.swing.GroupLayout.PREFERRED_SIZE, 84, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(NameField, javax.swing.GroupLayout.PREFERRED_SIZE, 112, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(76, Short.MAX_VALUE))
        );

        nodeInfoLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {highText, lowText});

        nodeInfoLayout.setVerticalGroup(
            nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(nodeInfoLayout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(nodeInfoLayout.createSequentialGroup()
                        .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(NameField, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel3))
                        .addGap(18, 18, 18)
                        .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(lowText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(jLabel1)))
                    .addComponent(LeafBox))
                .addGap(18, 18, 18)
                .addGroup(nodeInfoLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(highText, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2)
                    .addComponent(ConfirmButton))
                .addContainerGap(13, Short.MAX_VALUE))
        );

        CancelButton.setAction(actionMap.get("cancel")); // NOI18N
        CancelButton.setToolTipText(resourceMap.getString("CancelButton.toolTipText")); // NOI18N
        CancelButton.setName("CancelButton"); // NOI18N

        String[] dimNames=MultiDstruktApp.getApplication().getIDC().getDescription();
        dimChange.setModel(new javax.swing.DefaultComboBoxModel(dimNames));
        dimChange.setName("dimChange"); // NOI18N
        dimChange.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                dimChangeItemStateChanged(evt);
            }
        });

        dimName.setText(resourceMap.getString("dimName.text")); // NOI18N
        dimName.setName("dimName"); // NOI18N

        AddNode.setAction(actionMap.get("add")); // NOI18N
        AddNode.setToolTipText(resourceMap.getString("AddNode.toolTipText")); // NOI18N
        AddNode.setName("AddNode"); // NOI18N

        RemoveButton.setAction(actionMap.get("remove")); // NOI18N
        RemoveButton.setToolTipText(resourceMap.getString("RemoveButton.toolTipText")); // NOI18N
        RemoveButton.setName("RemoveButton"); // NOI18N

        javax.swing.GroupLayout mainpanelLayout = new javax.swing.GroupLayout(mainpanel);
        mainpanel.setLayout(mainpanelLayout);
        mainpanelLayout.setHorizontalGroup(
            mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(mainpanelLayout.createSequentialGroup()
                .addGap(67, 67, 67)
                .addComponent(OKButton, javax.swing.GroupLayout.PREFERRED_SIZE, 66, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 184, Short.MAX_VALUE)
                .addComponent(CancelButton, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(72, 72, 72))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, mainpanelLayout.createSequentialGroup()
                .addGap(26, 26, 26)
                .addComponent(dimName)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(dimChange, javax.swing.GroupLayout.PREFERRED_SIZE, 162, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(141, 141, 141))
            .addGroup(mainpanelLayout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addGroup(mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, mainpanelLayout.createSequentialGroup()
                        .addComponent(nodeInfo, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(20, 20, 20))
                    .addGroup(mainpanelLayout.createSequentialGroup()
                        .addComponent(TreePane, javax.swing.GroupLayout.DEFAULT_SIZE, 353, Short.MAX_VALUE)
                        .addGap(18, 18, 18)
                        .addGroup(mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(ClearButton)
                            .addComponent(AddNode, javax.swing.GroupLayout.PREFERRED_SIZE, 54, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(RemoveButton))
                        .addContainerGap())))
        );

        mainpanelLayout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {AddNode, ClearButton, RemoveButton});

        mainpanelLayout.setVerticalGroup(
            mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(mainpanelLayout.createSequentialGroup()
                .addGroup(mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(mainpanelLayout.createSequentialGroup()
                        .addGap(13, 13, 13)
                        .addGroup(mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(dimName)
                            .addComponent(dimChange, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addGap(18, 18, 18)
                        .addComponent(TreePane, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(6, 6, 6))
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, mainpanelLayout.createSequentialGroup()
                        .addContainerGap(82, Short.MAX_VALUE)
                        .addComponent(AddNode)
                        .addGap(30, 30, 30)
                        .addComponent(RemoveButton)
                        .addGap(27, 27, 27)
                        .addComponent(ClearButton)
                        .addGap(44, 44, 44)))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(nodeInfo, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(mainpanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(OKButton)
                    .addComponent(CancelButton))
                .addContainerGap())
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainpanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(mainpanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
        );

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-471)/2, (screenSize.height-518)/2, 471, 518);
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Event der ausgeloest wird, wenn man bei der Combobox eine andere Dimension auswaehlt.
     * Es wird der Hierarchiebaum der ausgewaehlten Hierarchie geladen.
     * @param evt
     */
    private void dimChangeItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_dimChangeItemStateChanged
        this.dimNr=this.dimChange.getSelectedIndex();
        this.rootNode=this.rootArray[dimNr];
        this.treeModel=this.treeArray[dimNr];
        this.treeModel.reload();
        // Sicht wird aktualisiert
        tree = new javax.swing.JTree(treeModel);
        TreePane.setViewportView(tree);
}//GEN-LAST:event_dimChangeItemStateChanged
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                SetHierarchie dialog = new SetHierarchie(new javax.swing.JFrame(), true,0);
                dialog.addWindowListener(new java.awt.event.WindowAdapter() {
                    public void windowClosing(java.awt.event.WindowEvent e) {
                        System.exit(0);
                    }
                });
                dialog.setVisible(true);
            }
        });
    }
    
    /**
     * Klicken von Add-Button. Panel unten wird aktiviert.
     */
    @Action
    public void add(){
        //Ermoeglicht das Setzen der Informationen        
        DefaultMutableTreeNode parentNode = null;
        TreePath parentPath = tree.getSelectionPath();

        if (parentPath == null) {
            parentNode = rootNode;
        } else {
            parentNode = (DefaultMutableTreeNode)
                         (parentPath.getLastPathComponent());
        }
        if (!parentNode.getAllowsChildren()){
            JOptionPane.showMessageDialog(MultiDstruktApp.getApplication().getMainFrame(),"Select another parent node,\n because this one is a Leaf!","", JOptionPane.ERROR_MESSAGE);
            return;
        }
        this.LeafBox.setSelected(false);
        this.LeafBox.setEnabled(true);
        this.NameField.setEnabled(true);
        this.jLabel3.setEnabled(true);
        this.ConfirmButton.setEnabled(true);
        this.lowText.setText("");
        this.highText.setText("");
        this.NameField.setText("");        
    }
    
    // Button Funktionen
    @Action
    public void remove(){
        removeCurrentNode();        
    }
    @Action
    public void clearButton(){
        clear();
    }
    @Action
    public void cancel(){
        this.dispose();
    }
    /**
     * Aenderungen der Hierarchie werden in IDC-Objekt uebernommen
     * @throws java.lang.Throwable
     */
    @Action
    public void okButtonPressed() throws Throwable{
        if (checkCorrect()){
            DimensionHierarchie[] hierarchies=new DimensionHierarchie[this.treeArray.length];
            for (int i=0;i<rootArray.length;i++){
                if (this.rootArray[i].getChildCount()!=0 && changed[i])
                    hierarchies[i]=getTreeHierarchie(this.rootArray[i]);                
            }
            IDC idc=MultiDstruktApp.getApplication().getIDC();
            for (int i=0;i<hierarchies.length;i++)
                //setzt Hierarchien nur dann neu, wenn sie auch geändert wurden
                if (changed[i]){
                    idc.dimension[i].setHierarchie(hierarchies[i]);
                    MultiDstruktApp.getApplication().hChanged=true;
                }
            this.dispose();
            this.finalize();
        }            
        
    }
    /**
     * Prueft, ob Hierarchien aller Dimensionen korrekt gesetzt wurden
     * @return true, falls alle Hierarchien korrekt
     */
    private boolean checkCorrect(){        
        for (int i=0;i<this.treeArray.length;i++)
            if (!checkCorrect(rootArray[i]))
                return false;
        return true;
        
        
    }
    /**
     * Prueft, ob ein Hierarchie-Knoten und der darunterliegende Teilbaum korrekt sind.
     * @param node
     * @return
     */
    private boolean checkCorrect(DefaultMutableTreeNode node){
        //Fall1: Knoten ist korrektes Blatt
        if (!node.getAllowsChildren())
            return true;
        //Fall2: Knoten wurde nicht als Blatt eingefuegt, hat aber keine Nachfolger
        if (node.getAllowsChildren()&& node.getChildCount()==0 && !node.isRoot()){
            JOptionPane.showMessageDialog(MultiDstruktApp.getApplication().getMainFrame(),"The Node "+((HierarchieInfo)node.getUserObject()).toString()+" is not a Leaf, but has no children.\n Please remove it or add some children!","", JOptionPane.ERROR_MESSAGE);
            return false;
        }
        //Knoten hat Nachfolger, rekursiver Aufruf für diese
        for (int i=0;i<node.getChildCount();i++)
            if (!checkCorrect((DefaultMutableTreeNode) node.getChildAt(i)))
                return false;       
        return true;
    }
    
    /**
     * Erzeugt aus einem Baum eine Dimensionshierarchie
     * @param root Wurzel des Baums
     * @return Durch den Baum repräsentierte DimensionsHierarchie
     */
    private DimensionHierarchie getTreeHierarchie(DefaultMutableTreeNode root){
        if (root.isLeaf())
            return new DimensionHierarchie(root.toString(),((HierarchieInfo) root.getUserObject()).lohi);
        DimensionHierarchie[] children=new DimensionHierarchie[root.getChildCount()];
        for (int i=0;i<children.length;i++){
            children[i]=getTreeHierarchie((DefaultMutableTreeNode) root.getChildAt(i));
        }
        return new DimensionHierarchie(root.toString(), children);
    }
    
    /**
     * Confirmed Button wird geklickt. Dadurch wird Knoten mit gewaehlten Eigenschaften
     * in die Baumansicht eingefuegt, sofern die eingegebenen Infos in Ordnung sind.
     */
    @Action
    public void confirmed(){
        //Erstellt aus den Informationen zugehöriges Objekt
        MutableTreeNode node;
        HierarchieInfo info;
        String name=this.NameField.getText();
        if (name.equals("")){
                JOptionPane.showMessageDialog(MultiDstruktApp.getApplication().getMainFrame(),"You haven't entered a name!","Empty Name", JOptionPane.ERROR_MESSAGE);
                return;
            }
        // Blatt soll erzeugt werden
        if (this.LeafBox.isSelected()){
            int low=-1;
            int high=-1;
            // Range wird ausgelesen
            try{
                low=Integer.parseInt(this.lowText.getText());
                high=Integer.parseInt(this.highText.getText());
            }
            catch(Exception e){}
            int size=MultiDstruktApp.getApplication().getIDC().getShape()[dimNr];
            if (low>high||high>=size||low<0){
                JOptionPane.showMessageDialog(MultiDstruktApp.getApplication().getMainFrame(),"The Range you entered is not correct!","False Range!", JOptionPane.ERROR_MESSAGE);
                return;
            }             
            
            info=new HierarchieInfo(name,low,high);  
            node=new DefaultMutableTreeNode(info,false);
        }
        // innerer Knoten soll erzeugt werden.
        else{
            info=new HierarchieInfo(name);
            node=new DefaultMutableTreeNode(info);
        }
        // Hierarchie der aktuellen Dimension wurde verändert
        changed[dimNr]=true;              
        //Fügt Objekt zum Baum hinzu
        this.addObject(node);
        this.lowText.setEnabled(false);
        this.highText.setEnabled(false);
        this.jLabel1.setEnabled(false);
        this.jLabel2.setEnabled(false);
        this.LeafBox.setSelected(false);
        this.LeafBox.setEnabled(false);
        this.NameField.setEnabled(false);
        this.jLabel3.setEnabled(false);
        this.ConfirmButton.setEnabled(false);        
    }
    
    /**
     * Leaf Check Box wird ausgewaehlt oder abgewaehlt.
     */
    @Action
    public void enableDisableButtons(){
        if (this.LeafBox.isSelected()){
            this.lowText.setEnabled(true);
            this.highText.setEnabled(true);
            this.jLabel1.setEnabled(true);
            this.jLabel2.setEnabled(true);
        }
        else{
            this.lowText.setEnabled(false);
            this.highText.setEnabled(false);
            this.jLabel1.setEnabled(false);
            this.jLabel2.setEnabled(false);
        }
    }
    
   
    // Die folgenden Methoden stammen von http://java.sun.com/docs/books/tutorial/uiswing/components/tree.html#dynamic
    // und wurden von uns an unsere Beduerfnisse angepasst.
    
    /** Remove all nodes except the root node. */
    public void clear() {
        rootNode.removeAllChildren();
        treeModel.reload();
        //Hierarchie wurde veraendert
        changed[dimNr]=true;
    }

    /** Remove the currently selected node. */
    public void removeCurrentNode() {
        TreePath currentSelection = tree.getSelectionPath();
        if (currentSelection != null) {
            DefaultMutableTreeNode currentNode = (DefaultMutableTreeNode)
                         (currentSelection.getLastPathComponent());
            MutableTreeNode parent = (MutableTreeNode)(currentNode.getParent());
            // Knoten wird nur entfernt, falls er nicht die Wurzel ist
            if (parent != null) {
                treeModel.removeNodeFromParent(currentNode);
                //Hierarchie wurde veraendert.
                changed[dimNr]=true;
                return;
            }
        } 
    }    
    

    /** Add child to the currently selected node. */
    public DefaultMutableTreeNode addObject(Object child) {
        DefaultMutableTreeNode parentNode = null;
        TreePath parentPath = tree.getSelectionPath();

        if (parentPath == null) {
            parentNode = rootNode;
        } else {
            parentNode = (DefaultMutableTreeNode)
                         (parentPath.getLastPathComponent());
        }       

        return addObject(parentNode, child, true);
    }

    public DefaultMutableTreeNode addObject(DefaultMutableTreeNode parent,
                                            Object child) {
        return addObject(parent, child, false);
    }

    public DefaultMutableTreeNode addObject(DefaultMutableTreeNode parent,
                                            Object child, 
                                            boolean shouldBeVisible) {
        DefaultMutableTreeNode childNode = (DefaultMutableTreeNode) child;

        if (parent == null) {
            parent = rootNode;
        }
	
	//Insert the node into the tree
        treeModel.insertNodeInto(childNode, parent, 
                                 parent.getChildCount());

        
        if (shouldBeVisible) {
            tree.scrollPathToVisible(new TreePath(childNode.getPath()));
        }
        return childNode;
    }
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton AddNode;
    private javax.swing.JButton CancelButton;
    private javax.swing.JButton ClearButton;
    private javax.swing.JButton ConfirmButton;
    private javax.swing.JCheckBox LeafBox;
    private javax.swing.JTextField NameField;
    private javax.swing.JButton OKButton;
    private javax.swing.JButton RemoveButton;
    private javax.swing.JScrollPane TreePane;
    private javax.swing.JComboBox dimChange;
    private javax.swing.JLabel dimName;
    private javax.swing.JTextField highText;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JTextField lowText;
    private javax.swing.JPanel mainpanel;
    private javax.swing.JPanel nodeInfo;
    private javax.swing.JTree tree;
    // End of variables declaration//GEN-END:variables
    protected DefaultMutableTreeNode rootNode;
    protected DefaultTreeModel treeModel;
    protected int dimNr;
    protected DefaultTreeModel[] treeArray;
    protected DefaultMutableTreeNode[] rootArray;
    protected boolean[] changed;
}
